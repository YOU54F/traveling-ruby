VERSION       = File.read("../VERSION.txt").strip
RUBY_VERSIONS = ENV['RUBY_VERSIONS'] ? [].push(ENV['RUBY_VERSIONS']) : File.read("../RUBY_VERSIONS.txt").strip.split(/\s+/)
ARCHITECTURES = ENV['ARCHITECTURES'] ? [].push(ENV['ARCHITECTURES']) : ["x86_64","x86"]

task :default => :package

desc "Create packages for all Ruby versions (#{RUBY_VERSIONS.join(' ')} and ARCHITECTURES (#{ARCHITECTURES.join(' ')})"
task :package do
  # Do nothing
end

desc "Build binaries for all Ruby versions (#{RUBY_VERSIONS.join(' ')})"
task :build do
  # Do nothing
end

desc "Test all Ruby versions (#{RUBY_VERSIONS.join(' ')})"
task :test do
  # Do nothing
end

desc "Upload all packages to the server"
task :upload do
  # Do nothing
end

desc "Clean all packages and binaries"
task :clean do
  sh "rm -rf output"
end

ARCHITECTURES.each do |arch|
  begin
  task :package => "package:#{arch}"


  RUBY_VERSIONS.each do |ruby_version|
    begin
    package = "traveling-ruby-#{VERSION}-#{ruby_version}-windows-#{arch}.tar.gz"
    package_full = "traveling-ruby-#{VERSION}-#{ruby_version}-windows-#{arch}-full.tar.gz"
    gem_dir = "traveling-ruby-gems-#{VERSION}-#{ruby_version}-windows-#{arch}"

    task :package => "package:#{arch}:#{ruby_version}"
    task :package_full => "package_full:#{ruby_version}:#{arch}"
    task :build   => "build:#{ruby_version}"
    task :test    => "test:#{ruby_version}:#{arch}"
    task :upload  => "upload:#{ruby_version}"
    task :clean   => "clean:#{ruby_version}"

    desc "Create packages for Platform #{arch}"
    task "package:#{arch}" => ["package:#{arch}:#{ruby_version}", "#{gem_dir}/ok"]

    desc "Create packages for Platform #{arch} Ruby Version #{ruby_version}"
    task "package:#{arch}:#{ruby_version}" => [package, "#{gem_dir}/ok"]

    desc "Build binaries for Ruby #{ruby_version}"
    task "build:#{ruby_version}" => "output/#{ruby_version}/#{arch}/bin"

    desc "Create full fat package for Ruby #{ruby_version} #{arch}"
    task "package_full:#{ruby_version}:#{arch}" => ["#{gem_dir}/ok"] do
      sh "./package.sh -f -r #{package_full} output/#{ruby_version}/#{arch}"
    end

    file(package => "output/#{ruby_version}/#{arch}/bin") do
      sh "./package.sh -r #{package} \"output/#{ruby_version}/#{arch}\""
    end

    file("#{gem_dir}/ok" => "output/#{ruby_version}/#{arch}/bin") do
      sh "./package.sh -E #{gem_dir} \"output/#{ruby_version}/#{arch}\""
      touch "#{gem_dir}/ok"
    end

    # We use 'file' instead of 'directory' here so that packages are updated
    # whenever we update binaries.
    file("output/#{ruby_version}/#{arch}/bin") do
      FileUtils.mkdir_p("cache")
      FileUtils.mkdir_p("output/#{ruby_version}/#{arch}")
      sh "./build-ruby.sh -a #{arch} -r #{ruby_version} cache \"output/#{ruby_version}/#{arch}\""
    end

    desc "Test Ruby #{ruby_version} #{arch}"
    task "test:#{ruby_version}:#{arch}" => "output/#{ruby_version}/#{arch}/bin" do
      sh "../shared/test-gems.sh -p windows -a #{arch} \"output/#{ruby_version}/#{arch}\""
    end

    desc "Upload Ruby #{ruby_version} packages to the server"
    task "upload:#{ruby_version}" => [package] do
      # sh "aws s3 cp #{package} s3://traveling-ruby/releases/ --acl public-read"
    end
    
    desc "Clean Ruby #{ruby_version} packages and binaries and runtime"
    task "clean:#{ruby_version}" do
      # sh "rm -rf \"#{package} \"output/#{ruby_version}/#{arch}\" cache\""
    end
    rescue Exception => e
      puts "Failed to build for Ruby #{ruby_version} on Architecture #{arch}"
      puts "Error: #{e.message}"
    end
  end
  rescue Exception => e
    puts "Failed to build for Ruby #{ruby_version} on Architecture #{arch}"
    puts "Error: #{e.message}"
  end
end
